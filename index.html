<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Respectable React Components</title>
    <link rel="stylesheet" type="text/css" href="build/build.css">
  </head>
  <body>
    <article>
      <section>
        <h1 class="title"><span>Respectable React Components</span></h1><img src="images/fitzwilliam-reactable-iii-respectable.png" style="width: 50%">
      </section>
      <section>
        <h1 class="title"><span>Performant React Components</span></h1><img src="images/fitzwilliam-reactable-iii-performant.png" style="width: 50%">
      </section>
      <section>
        <h1>Good news!</h1>
        <h2>Many of the ways you can make your React code more performant, actually makes it more maintainable too.</h2>
      </section>
      <section data-bespoke-backdrop="philosoraptor">
        <h1>But I&rsquo;ve heard React is already really performant</h1>
        <h2>...seriously, people go on and on about it.</h2>
      </section>
      <section>
        <h1>React is very efficient at DOM manipulation</h1>
        <h2>But there are other ways to inadvertently slow down your app.</h2>
      </section>
      <section>
        <h1>React 101: Props</h1>
        <h2>The public API of your component</h2>
        <pre><code class="language-javascript">var Hello = React.createClass({
  render() {
    return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;
  }
});

&lt;Hello name="Fitzwilliam Reactable III" /&gt; 
// &lt;h1&gt;Hello Fitzwilliam Reactable III&lt;/h1&gt;</code></pre><img src="images/fitzwilliam-reactable-iii-goodday.png" style="width: 25%">
      </section>
      <section>
        <h1>React 101: State</h1>
        <h2>The internal ... state ... of your component</h2>
        <pre><code class="language-javascript">update() { this.setState({ checked: true }) }

render() {
  return &lt;input checked={this.state.checked} /&gt;;
}
</code></pre><img src="images/fitzwilliam-reactable-iii-secrets.png" style="width: 25%">
      </section>
      <section>
        <h1>Virtual DOM</h1>
        <h2> A javascript representation of the DOM output of your components</h2>
        <div>
          <pre data-order="1" class="substep"><code class="language-javascript">&lt;UserInfo&gt;
  <span>&lt;UserName name="Fitzwilliam" /&gt;
&lt;/UserInfo&gt;
// &lt;div&gt; Hello &lt;span&gt;Fitzwilliam&lt;/span&gt; &lt;/div&gt;
</code></pre>
          <pre data-order="2" class="substep"><code class="language-javascript">&lt;UserInfo&gt;
  <span>&lt;UserName name="FitzFromTheBlock" /&gt;
&lt;/UserInfo&gt;
// &lt;div&gt; Hello &lt;span&gt;FitzFromTheBlock&lt;/span&gt; &lt;/div&gt;
</code></pre>
        </div>
      </section>
      <section>
        <h1>Virtual DOM</h1>
        <ul>
          <li>When updates happen, React's virtual DOM can determine the changes by diffing the original DOM with the re-computed one.</li>
          <li>Once the differences are established, React can update the browser DOM as efficiently as possible.</li>
          <li>~*~*~*~ performance ~*~*~*~</li>
        </ul>
      </section>
      <section>
        <h1>But remember</h1>
        <h2>Every time you update a component you’re re-computing that component inside React. Critically, you’re also re-computing its children, and grandchildren, and so on.</h2>
      </section>
      <section data-bespoke-backdrop="should">
        <h1 class="case-sensitive">shouldComponentUpdate( )</h1>
      </section>
      <section>
        <pre><code class="language-javascript">shouldComponentUpdate(nextProps, nextState) {
  return duh;
}
</code></pre>
      </section>
      <section>
        <h1>By default</h1>
        <pre><code class="language-javascript">shouldComponentUpdate(nextProps, nextState) {
  return true;
} 
</code></pre>
      </section>
      <section data-bespoke-backdrop="tree"></section>
      <section>
        <h1>So, basically</h1>
        <h2>shouldComponentUpdate helps you avoid computing your render tree when you don't need to</h2><img src="images/fitzwilliam-reactable-iii-yay.png" style="width: 50%">
      </section>
      <section>
        <h1 class="case-sensitive">PureRenderMixin</h1>
        <h2>How to use it</h2>
        <pre><code class="language-javascript">var PureRenderMixin = React.addons.PureRenderMixin;

var Heading = React.createClass({
  mixins: [PureRenderMixin],
  render() {
    return &lt;h1&gt;{this.props.text}&lt;/h1&gt;;
  }
});
</code></pre>
      </section>
      <section>
        <h1 class="case-sensitive">PureRenderMixin</h1>
        <h2>What it actually does</h2>
        <pre><code class="language-javascript">var ReactComponentWithPureRenderMixin = {
  shouldComponentUpdate: function(nextProps, nextState) {
    return !shallowEqual(this.props, nextProps) ||
           !shallowEqual(this.state, nextState);
  }
};
</code></pre>
      </section>
      <section>
        <h1 class="case-sensitive">PureRenderMixin isn't the catchall you're looking for</h1>
        <h2>There are non-comparable values that defeat it. For example:</h2>
        <ul>
          <li><code>this.props.children</code></li>
          <li>Functions where a new reference is passed each time<br><code>&lt;Foo something={e =&gt; dosomething()} /&gt;</code><br><code>&lt;Foo onClick={this.blah.bind(this)} /&gt;</code></li>
        </ul>
      </section>
      <section data-bespoke-backdrop="immutable">
        <h1><strong>Immutable Data</strong></h1>
      </section>
      <section>
        <h1>Immutable data gives you confidence</h1>
        <h2>If values change you always get a new reference.</h2>
      </section>
      <section>
        <h1 class="title"><span>Performance Tools</span></h1>
      </section>
      <section>
        <h1>React.addons.Perf</h1>
        <pre><code class="language-javascript">var Perf = React.addons.Perf;

Perf.start();
React.render( &lt;MyApp /&gt;, element );
Perf.stop();

Perf.printInclusive(); // Prints the overall time taken.
Perf.printExclusive(); // Time excluding mounting
Perf.printWasted();    // Time spent on components that
                       // didn't render anything</code></pre>
      </section>
      <section>
        <h1>Detect wasted time</h1>
        <h2>Run <code class="language-javascript">Perf.start()</code> from the console, interact with your app, and then run <code class="language-javascript">Perf.stop(); Perf.printWasted()</code></h2>
        <p>&nbsp;</p><img src="images/perf-wasted.png" style="width: 70%">
        <p>&nbsp;</p>
      </section>
      <section>
        <h1>React Render Visualizer </h1>
        <h3><a href="https://github.com/redsunsoft/react-render-visualizer">github.com/redsunsoft/react-render-visualizer</a></h3><img src="images/react-render-visializer.gif" style="width: 50%; height: auto">
      </section>
      <section data-bespoke-backdrop="fdt" class="invert"><img src="images/fdt_logo.png" style="width: 50%">
        <h3>Facebook's first open source React component</h3>
      </section>
      <section data-bespoke-backdrop="fdt-lies">
        <h1>NOT A REAL SCROLLBAR</h1>
        <h2>Loads in only the rows currently in the viewport, and a buffer to ease scrolling. Then update state of visible rows when the scroll event fires.</h2>
      </section>
      <section>
        <h1>Consider only rendering what the user can see</h1>
      </section>
      <section>
        <h1>To sum up</h1>
        <ul>
          <li>shouldComponentUpdate? Ideally not.</li>
          <li>PureRenderMixin is pretty great</li>
          <li>Immutable Data will make your life better</li>
          <li>Performance tools are your friend</li>
          <li>Only render what you need to (level 80)</li>
          <li>But also&hellip;</li>
          <li>How you stucture and compose your components will<br>have a big imapct on how it performs</li>
        </ul>
      </section>
      <section data-bespoke-backdrop="conf" class="invert">
        <div class="bg">
          <h1>Jason Bonta did a talk on this which is better.</h1>
          <h2><a href="http://conf.reactjs.com/schedule.html#making-your-app-fast-with-high-performance-components">You should watch it</a></h2>
        </div>
      </section>
      <section><img src="images/fitzwilliam-reactable-iii-thanks.png" style="width: 65%">
        <h2 class="no-border">twitter: <a href="https://twitter.com/kelle_c">kelle_c</a></h2>
        <h2 class="no-border">github: <a href="https://github.com/kellec">kellec</a></h2>
        <h3>Special thanks to Cam, Pieter, &amp; Kat for the help and advice &lt;3</h3>
      </section>
    </article>
    <script src="build/build.js"></script>
  </body>
</html>